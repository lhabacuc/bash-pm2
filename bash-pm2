#!/bin/bash

# =============================================
# bash-pm2 - Gerenciador de Processos Completo
# Sem sudo | Auto-restart | Boot 24/7
# =============================================

set -e

PM2_HOME="$HOME/.bash-pm2"
PID_DIR="$PM2_HOME/pids"
LOG_DIR="$PM2_HOME/logs"
CONF_FILE="$PM2_HOME/config"
META_FILE="$PM2_HOME/metadata"
SCRIPT_PATH="$HOME/bin/bash-pm2"
SERVICE_FILE="$HOME/.config/systemd/user/bash-pm2.service"

# === CORES ===
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# === FUNÇÕES AUXILIARES ===
log() { echo -e "${BLUE}[$(date +'%H:%M:%S')]${NC} $*"; }
success() { echo -e "${GREEN}✓${NC} $*"; }
error() { echo -e "${RED}✗${NC} $*"; }
warn() { echo -e "${YELLOW}⚠${NC} $*"; }

# Salva metadados do processo
save_metadata() {
    local name="$1" cmd="$2"
    local created=$(date +%s)
    local restarts=0
    
    # Preserva contador de restarts se existir
    if grep -q "^$name|" "$META_FILE" 2>/dev/null; then
        restarts=$(grep "^$name|" "$META_FILE" | cut -d'|' -f4)
    fi
    
    grep -v "^$name|" "$META_FILE" > "$META_FILE.tmp" 2>/dev/null || true
    echo "$name|$cmd|$created|$restarts" >> "$META_FILE.tmp"
    mv "$META_FILE.tmp" "$META_FILE"
}

# Incrementa contador de restarts
increment_restarts() {
    local name="$1"
    local line=$(grep "^$name|" "$META_FILE" 2>/dev/null || echo "")
    if [ -n "$line" ]; then
        local cmd=$(echo "$line" | cut -d'|' -f2)
        local created=$(echo "$line" | cut -d'|' -f3)
        local restarts=$(echo "$line" | cut -d'|' -f4)
        restarts=$((restarts + 1))
        
        grep -v "^$name|" "$META_FILE" > "$META_FILE.tmp" 2>/dev/null || true
        echo "$name|$cmd|$created|$restarts" >> "$META_FILE.tmp"
        mv "$META_FILE.tmp" "$META_FILE"
    fi
}

# Calcula uptime formatado
format_uptime() {
    local created="$1"
    local now=$(date +%s)
    local diff=$((now - created))
    
    local days=$((diff / 86400))
    local hours=$(( (diff % 86400) / 3600 ))
    local mins=$(( (diff % 3600) / 60 ))
    
    if [ $days -gt 0 ]; then
        echo "${days}d ${hours}h"
    elif [ $hours -gt 0 ]; then
        echo "${hours}h ${mins}m"
    else
        echo "${mins}m"
    fi
}

# === AUTO-INSTALAÇÃO ===
install() {
    log "Instalando bash-pm2..."

    mkdir -p "$HOME/bin" "$PID_DIR" "$LOG_DIR" "$HOME/.config/systemd/user"
    touch "$CONF_FILE" "$META_FILE"

    # Copia o script para ~/bin
    cp "$0" "$SCRIPT_PATH"
    chmod +x "$SCRIPT_PATH"

    # Adiciona ao PATH se necessário
    if ! echo "$PATH" | grep -q "$HOME/bin"; then
        for rc in "$HOME/.bashrc" "$HOME/.zshrc" "$HOME/.profile"; do
            if [ -f "$rc" ]; then
                echo 'export PATH="$HOME/bin:$PATH"' >> "$rc"
                warn "Adicionado $HOME/bin ao PATH em $rc"
            fi
        done
    fi

    # Cria serviço systemd do usuário
    cat > "$SERVICE_FILE" << 'EOFSERVICE'
[Unit]
Description=Bash PM2 - Gerenciador de processos do usuário
After=network.target

[Service]
Type=simple
ExecStart=%h/bin/bash-pm2 daemon
Restart=always
RestartSec=5
Environment=PATH=%h/bin:/usr/local/bin:/usr/bin:/bin
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=default.target
EOFSERVICE

    # Recarrega e habilita
    systemctl --user daemon-reload
    if systemctl --user enable --now bash-pm2.service 2>/dev/null; then
        success "Serviço systemd habilitado e iniciado"
    else
        warn "Serviço criado, mas não pôde ser iniciado automaticamente"
        echo "   Execute: systemctl --user enable --now bash-pm2.service"
    fi

    # Habilita linger (permite rodar após logout)
    if command -v loginctl &>/dev/null; then
        loginctl enable-linger "$USER" 2>/dev/null || warn "Não foi possível habilitar linger (precisa de sudo)"
    fi

    success "bash-pm2 instalado com sucesso!"
    echo ""
    echo "Comandos disponíveis:"
    echo "   bash-pm2 start 'node app.js' --name api"
    echo "   bash-pm2 list"
    echo "   bash-pm2 status api"
    echo "   bash-pm2 logs api -f"
    echo "   bash-pm2 stop api"
    echo "   bash-pm2 restart api"
    echo ""
    echo "Status do daemon: systemctl --user status bash-pm2"
    exit 0
}

# === PROCESSOS ===
start_process() {
    local name="$1" cmd="$2"
    local pid_file="$PID_DIR/$name.pid" 
    local log_file="$LOG_DIR/$name.log"
    local err_file="$LOG_DIR/$name.err.log"

    if [ -f "$pid_file" ] && kill -0 "$(cat "$pid_file")" 2>/dev/null; then
        warn "[$name] Já está rodando (PID: $(cat "$pid_file"))"
        return 1
    fi

    log "[$name] Iniciando: $cmd"
    
    # Inicia processo em background com logs separados
    (
        exec bash -c "$cmd" >> "$log_file" 2>> "$err_file"
    ) &
    
    local pid=$!
    echo $pid > "$pid_file"
    
    # Aguarda 1s e verifica se ainda está rodando
    sleep 1
    if kill -0 "$pid" 2>/dev/null; then
        success "[$name] Iniciado com PID: $pid"
        save_metadata "$name" "$cmd"
        return 0
    else
        error "[$name] Falhou ao iniciar. Veja: bash-pm2 logs $name"
        rm -f "$pid_file"
        return 1
    fi
}

stop_process() {
    local name="$1" 
    local pid_file="$PID_DIR/$name.pid"
    
    [ ! -f "$pid_file" ] && { error "[$name] Processo não encontrado."; return 1; }

    local pid=$(cat "$pid_file")
    if kill -0 "$pid" 2>/dev/null; then
        log "[$name] Parando PID $pid..."
        
        # Tenta TERM, depois KILL
        kill -TERM "$pid" 2>/dev/null || true
        
        for i in {1..10}; do
            if ! kill -0 "$pid" 2>/dev/null; then
                break
            fi
            sleep 0.5
        done
        
        # Força se ainda estiver vivo
        if kill -0 "$pid" 2>/dev/null; then
            kill -9 "$pid" 2>/dev/null || true
            warn "[$name] Processo forçado (SIGKILL)"
        fi
    fi
    
    rm -f "$pid_file"
    grep -v "^$name|" "$META_FILE" > "$META_FILE.tmp" 2>/dev/null || true
    mv "$META_FILE.tmp" "$META_FILE" 2>/dev/null || true
    
    success "[$name] Parado."
}

status_process() {
    local name="$1" 
    local pid_file="$PID_DIR/$name.pid"
    local verbose="$2"
    
    if [ -f "$pid_file" ]; then
        local pid=$(cat "$pid_file")
        local meta=$(grep "^$name|" "$META_FILE" 2>/dev/null || echo "")
        
        if kill -0 "$pid" 2>/dev/null; then
            local cmd=$(echo "$meta" | cut -d'|' -f2)
            local created=$(echo "$meta" | cut -d'|' -f3)
            local restarts=$(echo "$meta" | cut -d'|' -f4)
            local uptime=$(format_uptime "$created")
            
            if [ "$verbose" = "verbose" ]; then
                echo -e "${GREEN}●${NC} $name"
                echo "   Status:    ${GREEN}online${NC}"
                echo "   PID:       $pid"
                echo "   Uptime:    $uptime"
                echo "   Restarts:  $restarts"
                echo "   Command:   $cmd"
                echo "   Log:       $LOG_DIR/$name.log"
            else
                printf "${GREEN}%-20s${NC} ${CYAN}%-8s${NC} %-10s restarts:%-3s %s\n" \
                    "$name" "online" "$uptime" "$restarts" "PID:$pid"
            fi
        else
            if [ "$verbose" = "verbose" ]; then
                echo -e "${RED}●${NC} $name"
                echo "   Status:    ${RED}stopped${NC} (stale PID: $pid)"
            else
                printf "${RED}%-20s${NC} ${RED}%-8s${NC}\n" "$name" "stopped"
            fi
            rm -f "$pid_file"
        fi
    else
        if [ "$verbose" = "verbose" ]; then
            echo -e "${YELLOW}○${NC} $name"
            echo "   Status:    ${YELLOW}not running${NC}"
        else
            printf "${YELLOW}%-20s${NC} ${YELLOW}%-8s${NC}\n" "$name" "stopped"
        fi
    fi
}

# === DAEMON (monitoramento) ===
daemon() {
    log "bash-pm2 daemon iniciado (monitoramento a cada 5s)"
    log "PID do daemon: $$"
    
    while true; do
        for pid_file in "$PID_DIR"/*.pid; do
            [ -f "$pid_file" ] || continue
            
            name=$(basename "$pid_file" .pid)
            pid=$(cat "$pid_file" 2>/dev/null || echo "")
            
            if [ -n "$pid" ] && ! kill -0 "$pid" 2>/dev/null; then
                warn "[$name] Processo caiu (PID: $pid)! Reiniciando..."
                
                # Busca comando no config
                cmd=$(grep "^$name:" "$CONF_FILE" 2>/dev/null | cut -d: -f2-)
                
                if [ -n "$cmd" ]; then
                    increment_restarts "$name"
                    
                    # Remove PID antigo e reinicia
                    rm -f "$pid_file"
                    start_process "$name" "$cmd"
                else
                    error "[$name] Comando não encontrado no config. Removendo PID."
                    rm -f "$pid_file"
                fi
            fi
        done
        sleep 5
    done
}

# === CLI ===
case "$1" in
    install|--install|-i)
        install
        ;;

    start)
        NAME="" CMD=""
        shift
        while [ $# -gt 0 ]; do
            case "$1" in
                --name|-n) NAME="$2"; shift 2 ;;
                *) CMD="$CMD $1"; shift ;;
            esac
        done
        CMD="${CMD:1}"
        
        [ -z "$NAME" ] && NAME="proc_$(date +%s)"
        [ -z "$CMD" ] && { error "Erro: comando vazio."; exit 1; }

        # Salva no config (remove linha antiga)
        grep -v "^$NAME:" "$CONF_FILE" > "$CONF_FILE.tmp" 2>/dev/null || true
        echo "$NAME:$CMD" >> "$CONF_FILE.tmp"
        mv "$CONF_FILE.tmp" "$CONF_FILE"

        start_process "$NAME" "$CMD"
        ;;

    stop)
        [ -z "$2" ] && { error "Use: bash-pm2 stop <nome>"; exit 1; }
        stop_process "$2"
        
        # Remove do config
        grep -v "^$2:" "$CONF_FILE" > "$CONF_FILE.tmp" 2>/dev/null || true
        mv "$CONF_FILE.tmp" "$CONF_FILE"
        ;;

    restart)
        [ -z "$2" ] && { error "Use: bash-pm2 restart <nome>"; exit 1; }
        
        cmd=$(grep "^$2:" "$CONF_FILE" 2>/dev/null | cut -d: -f2-)
        [ -z "$cmd" ] && { error "[$2] Não encontrado no config."; exit 1; }
        
        stop_process "$2" 2>/dev/null || true
        sleep 1
        start_process "$2" "$cmd"
        ;;

    status)
        if [ -n "$2" ]; then
            status_process "$2" "verbose"
        else
            echo -e "\n${CYAN}bash-pm2 status:${NC}\n"
            printf "%-20s %-8s %-10s %-12s %s\n" "NAME" "STATUS" "UPTIME" "RESTARTS" "PID"
            echo "────────────────────────────────────────────────────────────"
            
            count=0
            for pid_file in "$PID_DIR"/*.pid; do
                [ -f "$pid_file" ] || continue
                name=$(basename "$pid_file" .pid)
                status_process "$name"
                count=$((count + 1))
            done
            
            if [ $count -eq 0 ]; then
                echo "Nenhum processo rodando."
            fi
            echo ""
        fi
        ;;

    list|ls)
        echo -e "\n${CYAN}Processos gerenciados:${NC}\n"
        printf "%-20s %-8s %-10s %-12s %s\n" "NAME" "STATUS" "UPTIME" "RESTARTS" "PID"
        echo "────────────────────────────────────────────────────────────"
        
        count=0
        for pid_file in "$PID_DIR"/*.pid; do
            [ -f "$pid_file" ] || continue
            name=$(basename "$pid_file" .pid)
            status_process "$name"
            count=$((count + 1))
        done
        
        if [ $count -eq 0 ]; then
            echo "Nenhum processo rodando."
        fi
        echo ""
        ;;

    logs)
        [ -z "$2" ] && { error "Use: bash-pm2 logs <nome> [-f] [-n 50] [--err]"; exit 1; }
        
        NAME="$2"
        FOLLOW=""
        LINES="50"
        TYPE="log"
        shift 2
        
        while [ $# -gt 0 ]; do
            case "$1" in
                -f|--follow) FOLLOW="-f"; shift ;;
                -n|--lines) LINES="$2"; shift 2 ;;
                --err|--error) TYPE="err.log"; shift ;;
                *) shift ;;
            esac
        done
        
        LOG_FILE="$LOG_DIR/$NAME.$TYPE"
        
        if [ ! -f "$LOG_FILE" ]; then
            error "Log não encontrado: $LOG_FILE"
            exit 1
        fi
        
        if [ -n "$FOLLOW" ]; then
            log "Seguindo logs de [$NAME] (Ctrl+C para sair)..."
            tail -n "$LINES" $FOLLOW "$LOG_FILE"
        else
            tail -n "$LINES" "$LOG_FILE"
        fi
        ;;

    delete|del|rm)
        [ -z "$2" ] && { error "Use: bash-pm2 delete <nome>"; exit 1; }
        
        stop_process "$2" 2>/dev/null || true
        grep -v "^$2:" "$CONF_FILE" > "$CONF_FILE.tmp" 2>/dev/null || true
        mv "$CONF_FILE.tmp" "$CONF_FILE"
        grep -v "^$2|" "$META_FILE" > "$META_FILE.tmp" 2>/dev/null || true
        mv "$META_FILE.tmp" "$META_FILE"
        
        success "[$2] Removido do bash-pm2."
        ;;

    flush)
        log "Limpando logs..."
        rm -f "$LOG_DIR"/*.log
        success "Logs limpos."
        ;;

    daemon)
        daemon
        ;;

    info)
        echo -e "\n${CYAN}bash-pm2 System Info:${NC}\n"
        echo "Home:      $PM2_HOME"
        echo "PIDs:      $PID_DIR"
        echo "Logs:      $LOG_DIR"
        echo "Config:    $CONF_FILE"
        echo "Service:   $SERVICE_FILE"
        echo ""
        
        if systemctl --user is-active --quiet bash-pm2.service 2>/dev/null; then
            echo -e "Daemon:    ${GREEN}active${NC}"
        else
            echo -e "Daemon:    ${RED}inactive${NC}"
        fi
        
        echo ""
        echo "Use 'systemctl --user status bash-pm2' para mais detalhes."
        echo ""
        ;;

    *)
        echo -e "${CYAN}bash-pm2${NC} - Gerenciador de Processos Profissional"
        echo ""
        echo "Instalação:"
        echo "   bash-pm2 install"
        echo ""
        echo "Uso:"
        echo "   bash-pm2 start 'comando' --name <nome>   Inicia um processo"
        echo "   bash-pm2 list                            Lista todos os processos"
        echo "   bash-pm2 status [nome]                   Status detalhado"
        echo "   bash-pm2 logs <nome> [-f] [-n 50]        Mostra logs"
        echo "   bash-pm2 logs <nome> --err               Mostra logs de erro"
        echo "   bash-pm2 stop <nome>                     Para um processo"
        echo "   bash-pm2 restart <nome>                  Reinicia um processo"
        echo "   bash-pm2 delete <nome>                   Remove do gerenciador"
        echo "   bash-pm2 flush                           Limpa todos os logs"
        echo "   bash-pm2 info                            Info do sistema"
        echo ""
        echo "Exemplos:"
        echo "   bash-pm2 start 'python -m http.server 8080' --name webserver"
        echo "   bash-pm2 start 'node app.js' -n api"
        echo "   bash-pm2 logs api -f"
        echo ""
        ;;
esac
